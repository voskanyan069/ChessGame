// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ChessServer.proto
#ifndef GRPC_ChessServer_2eproto__INCLUDED
#define GRPC_ChessServer_2eproto__INCLUDED

#include "ChessServer.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace Proto {

class ChessServer final {
 public:
  static constexpr char const* service_full_name() {
    return "Proto.ChessServer";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetRooms(::grpc::ClientContext* context, const ::Proto::Empty& request, ::Proto::RoomsInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::RoomsInfo>> AsyncGetRooms(::grpc::ClientContext* context, const ::Proto::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::RoomsInfo>>(AsyncGetRoomsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::RoomsInfo>> PrepareAsyncGetRooms(::grpc::ClientContext* context, const ::Proto::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::RoomsInfo>>(PrepareAsyncGetRoomsRaw(context, request, cq));
    }
    virtual ::grpc::Status IsRoomExists(::grpc::ClientContext* context, const ::Proto::String& request, ::Proto::Bool* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Bool>> AsyncIsRoomExists(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Bool>>(AsyncIsRoomExistsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Bool>> PrepareAsyncIsRoomExists(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Bool>>(PrepareAsyncIsRoomExistsRaw(context, request, cq));
    }
    virtual ::grpc::Status CreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::Proto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> AsyncCreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(AsyncCreateRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> PrepareAsyncCreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(PrepareAsyncCreateRoomRaw(context, request, cq));
    }
    virtual ::grpc::Status JoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::Proto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> AsyncJoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(AsyncJoinRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> PrepareAsyncJoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(PrepareAsyncJoinRoomRaw(context, request, cq));
    }
    virtual ::grpc::Status LeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::Proto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> AsyncLeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(AsyncLeaveRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> PrepareAsyncLeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(PrepareAsyncLeaveRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::Proto::LastMoveInfo>> SpectateRoom(::grpc::ClientContext* context, const ::Proto::String& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::Proto::LastMoveInfo>>(SpectateRoomRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::Proto::LastMoveInfo>> AsyncSpectateRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::Proto::LastMoveInfo>>(AsyncSpectateRoomRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::Proto::LastMoveInfo>> PrepareAsyncSpectateRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::Proto::LastMoveInfo>>(PrepareAsyncSpectateRoomRaw(context, request, cq));
    }
    virtual ::grpc::Status LeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::Proto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> AsyncLeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(AsyncLeaveSpectatorRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> PrepareAsyncLeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(PrepareAsyncLeaveSpectatorRoomRaw(context, request, cq));
    }
    virtual ::grpc::Status GetViewersCount(::grpc::ClientContext* context, const ::Proto::String& request, ::Proto::Integer* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Integer>> AsyncGetViewersCount(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Integer>>(AsyncGetViewersCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Integer>> PrepareAsyncGetViewersCount(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Integer>>(PrepareAsyncGetViewersCountRaw(context, request, cq));
    }
    virtual ::grpc::Status GetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::Proto::String* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::String>> AsyncGetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::String>>(AsyncGetUsernameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::String>> PrepareAsyncGetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::String>>(PrepareAsyncGetUsernameRaw(context, request, cq));
    }
    virtual ::grpc::Status WaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::Proto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> AsyncWaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(AsyncWaitForReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> PrepareAsyncWaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(PrepareAsyncWaitForReadyRaw(context, request, cq));
    }
    virtual ::grpc::Status Ready(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::Proto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> AsyncReady(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(AsyncReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> PrepareAsyncReady(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(PrepareAsyncReadyRaw(context, request, cq));
    }
    virtual ::grpc::Status MovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::Proto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> AsyncMovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(AsyncMovePieceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> PrepareAsyncMovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(PrepareAsyncMovePieceRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::Proto::LastMoveInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::LastMoveInfo>> AsyncReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::LastMoveInfo>>(AsyncReadPieceMoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::LastMoveInfo>> PrepareAsyncReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::LastMoveInfo>>(PrepareAsyncReadPieceMoveRaw(context, request, cq));
    }
    virtual ::grpc::Status SetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::Proto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> AsyncSetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(AsyncSetKingHittableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>> PrepareAsyncSetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>>(PrepareAsyncSetKingHittableRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GetRooms(::grpc::ClientContext* context, const ::Proto::Empty* request, ::Proto::RoomsInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRooms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::RoomsInfo* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRooms(::grpc::ClientContext* context, const ::Proto::Empty* request, ::Proto::RoomsInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRooms(::grpc::ClientContext* context, const ::Proto::Empty* request, ::Proto::RoomsInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRooms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::RoomsInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRooms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::RoomsInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void IsRoomExists(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Bool* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsRoomExists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Bool* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void IsRoomExists(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void IsRoomExists(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void IsRoomExists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Bool* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void IsRoomExists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void CreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void JoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void JoinRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void JoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void JoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void JoinRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void JoinRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void LeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LeaveRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeaveRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeaveRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SpectateRoom(::grpc::ClientContext* context, ::Proto::String* request, ::grpc::ClientReadReactor< ::Proto::LastMoveInfo>* reactor) = 0;
      #else
      virtual void SpectateRoom(::grpc::ClientContext* context, ::Proto::String* request, ::grpc::experimental::ClientReadReactor< ::Proto::LastMoveInfo>* reactor) = 0;
      #endif
      virtual void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetViewersCount(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Integer* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetViewersCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Integer* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetViewersCount(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Integer* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetViewersCount(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Integer* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetViewersCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Integer* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetViewersCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Integer* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::String* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetUsername(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::String* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::String* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::String* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetUsername(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::String* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetUsername(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::String* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void WaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WaitForReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WaitForReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WaitForReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Ready(::grpc::ClientContext* context, const ::Proto::ReadyRequest* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Ready(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Ready(::grpc::ClientContext* context, const ::Proto::ReadyRequest* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Ready(::grpc::ClientContext* context, const ::Proto::ReadyRequest* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Ready(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Ready(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void MovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MovePiece(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MovePiece(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MovePiece(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::LastMoveInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReadPieceMove(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::LastMoveInfo* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::LastMoveInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::LastMoveInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadPieceMove(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::LastMoveInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadPieceMove(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::LastMoveInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetKingHittable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetKingHittable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetKingHittable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::RoomsInfo>* AsyncGetRoomsRaw(::grpc::ClientContext* context, const ::Proto::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::RoomsInfo>* PrepareAsyncGetRoomsRaw(::grpc::ClientContext* context, const ::Proto::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Bool>* AsyncIsRoomExistsRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Bool>* PrepareAsyncIsRoomExistsRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* AsyncCreateRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* PrepareAsyncCreateRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* AsyncJoinRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* PrepareAsyncJoinRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* AsyncLeaveRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* PrepareAsyncLeaveRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::Proto::LastMoveInfo>* SpectateRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::Proto::LastMoveInfo>* AsyncSpectateRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::Proto::LastMoveInfo>* PrepareAsyncSpectateRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* AsyncLeaveSpectatorRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* PrepareAsyncLeaveSpectatorRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Integer>* AsyncGetViewersCountRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Integer>* PrepareAsyncGetViewersCountRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::String>* AsyncGetUsernameRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::String>* PrepareAsyncGetUsernameRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* AsyncWaitForReadyRaw(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* PrepareAsyncWaitForReadyRaw(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* AsyncReadyRaw(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* PrepareAsyncReadyRaw(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* AsyncMovePieceRaw(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* PrepareAsyncMovePieceRaw(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::LastMoveInfo>* AsyncReadPieceMoveRaw(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::LastMoveInfo>* PrepareAsyncReadPieceMoveRaw(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* AsyncSetKingHittableRaw(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Proto::Empty>* PrepareAsyncSetKingHittableRaw(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetRooms(::grpc::ClientContext* context, const ::Proto::Empty& request, ::Proto::RoomsInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::RoomsInfo>> AsyncGetRooms(::grpc::ClientContext* context, const ::Proto::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::RoomsInfo>>(AsyncGetRoomsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::RoomsInfo>> PrepareAsyncGetRooms(::grpc::ClientContext* context, const ::Proto::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::RoomsInfo>>(PrepareAsyncGetRoomsRaw(context, request, cq));
    }
    ::grpc::Status IsRoomExists(::grpc::ClientContext* context, const ::Proto::String& request, ::Proto::Bool* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Bool>> AsyncIsRoomExists(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Bool>>(AsyncIsRoomExistsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Bool>> PrepareAsyncIsRoomExists(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Bool>>(PrepareAsyncIsRoomExistsRaw(context, request, cq));
    }
    ::grpc::Status CreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::Proto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> AsyncCreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(AsyncCreateRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> PrepareAsyncCreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(PrepareAsyncCreateRoomRaw(context, request, cq));
    }
    ::grpc::Status JoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::Proto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> AsyncJoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(AsyncJoinRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> PrepareAsyncJoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(PrepareAsyncJoinRoomRaw(context, request, cq));
    }
    ::grpc::Status LeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::Proto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> AsyncLeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(AsyncLeaveRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> PrepareAsyncLeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(PrepareAsyncLeaveRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::Proto::LastMoveInfo>> SpectateRoom(::grpc::ClientContext* context, const ::Proto::String& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::Proto::LastMoveInfo>>(SpectateRoomRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::Proto::LastMoveInfo>> AsyncSpectateRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::Proto::LastMoveInfo>>(AsyncSpectateRoomRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::Proto::LastMoveInfo>> PrepareAsyncSpectateRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::Proto::LastMoveInfo>>(PrepareAsyncSpectateRoomRaw(context, request, cq));
    }
    ::grpc::Status LeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::Proto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> AsyncLeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(AsyncLeaveSpectatorRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> PrepareAsyncLeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(PrepareAsyncLeaveSpectatorRoomRaw(context, request, cq));
    }
    ::grpc::Status GetViewersCount(::grpc::ClientContext* context, const ::Proto::String& request, ::Proto::Integer* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Integer>> AsyncGetViewersCount(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Integer>>(AsyncGetViewersCountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Integer>> PrepareAsyncGetViewersCount(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Integer>>(PrepareAsyncGetViewersCountRaw(context, request, cq));
    }
    ::grpc::Status GetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::Proto::String* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::String>> AsyncGetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::String>>(AsyncGetUsernameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::String>> PrepareAsyncGetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::String>>(PrepareAsyncGetUsernameRaw(context, request, cq));
    }
    ::grpc::Status WaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::Proto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> AsyncWaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(AsyncWaitForReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> PrepareAsyncWaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(PrepareAsyncWaitForReadyRaw(context, request, cq));
    }
    ::grpc::Status Ready(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::Proto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> AsyncReady(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(AsyncReadyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> PrepareAsyncReady(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(PrepareAsyncReadyRaw(context, request, cq));
    }
    ::grpc::Status MovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::Proto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> AsyncMovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(AsyncMovePieceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> PrepareAsyncMovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(PrepareAsyncMovePieceRaw(context, request, cq));
    }
    ::grpc::Status ReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::Proto::LastMoveInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::LastMoveInfo>> AsyncReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::LastMoveInfo>>(AsyncReadPieceMoveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::LastMoveInfo>> PrepareAsyncReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::LastMoveInfo>>(PrepareAsyncReadPieceMoveRaw(context, request, cq));
    }
    ::grpc::Status SetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::Proto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> AsyncSetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(AsyncSetKingHittableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>> PrepareAsyncSetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Proto::Empty>>(PrepareAsyncSetKingHittableRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetRooms(::grpc::ClientContext* context, const ::Proto::Empty* request, ::Proto::RoomsInfo* response, std::function<void(::grpc::Status)>) override;
      void GetRooms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::RoomsInfo* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRooms(::grpc::ClientContext* context, const ::Proto::Empty* request, ::Proto::RoomsInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRooms(::grpc::ClientContext* context, const ::Proto::Empty* request, ::Proto::RoomsInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRooms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::RoomsInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRooms(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::RoomsInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void IsRoomExists(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Bool* response, std::function<void(::grpc::Status)>) override;
      void IsRoomExists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Bool* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void IsRoomExists(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void IsRoomExists(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void IsRoomExists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Bool* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void IsRoomExists(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Bool* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      void CreateRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void JoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      void JoinRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void JoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void JoinRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void JoinRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void JoinRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      void LeaveRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeaveRoom(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeaveRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeaveRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SpectateRoom(::grpc::ClientContext* context, ::Proto::String* request, ::grpc::ClientReadReactor< ::Proto::LastMoveInfo>* reactor) override;
      #else
      void SpectateRoom(::grpc::ClientContext* context, ::Proto::String* request, ::grpc::experimental::ClientReadReactor< ::Proto::LastMoveInfo>* reactor) override;
      #endif
      void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeaveSpectatorRoom(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetViewersCount(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Integer* response, std::function<void(::grpc::Status)>) override;
      void GetViewersCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Integer* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetViewersCount(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Integer* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetViewersCount(::grpc::ClientContext* context, const ::Proto::String* request, ::Proto::Integer* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetViewersCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Integer* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetViewersCount(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Integer* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::String* response, std::function<void(::grpc::Status)>) override;
      void GetUsername(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::String* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::String* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetUsername(::grpc::ClientContext* context, const ::Proto::RoomWithUsername* request, ::Proto::String* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetUsername(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::String* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetUsername(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::String* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      void WaitForReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WaitForReady(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WaitForReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WaitForReady(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Ready(::grpc::ClientContext* context, const ::Proto::ReadyRequest* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      void Ready(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Ready(::grpc::ClientContext* context, const ::Proto::ReadyRequest* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Ready(::grpc::ClientContext* context, const ::Proto::ReadyRequest* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Ready(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Ready(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      void MovePiece(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MovePiece(::grpc::ClientContext* context, const ::Proto::MoveRequest* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MovePiece(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MovePiece(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::LastMoveInfo* response, std::function<void(::grpc::Status)>) override;
      void ReadPieceMove(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::LastMoveInfo* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::LastMoveInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadPieceMove(::grpc::ClientContext* context, const ::Proto::RoomSettings* request, ::Proto::LastMoveInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadPieceMove(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::LastMoveInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadPieceMove(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::LastMoveInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetKingHittable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetKingHittable(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetKingHittable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetKingHittable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::Proto::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::Proto::RoomsInfo>* AsyncGetRoomsRaw(::grpc::ClientContext* context, const ::Proto::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::RoomsInfo>* PrepareAsyncGetRoomsRaw(::grpc::ClientContext* context, const ::Proto::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Bool>* AsyncIsRoomExistsRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Bool>* PrepareAsyncIsRoomExistsRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* AsyncCreateRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* PrepareAsyncCreateRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* AsyncJoinRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* PrepareAsyncJoinRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* AsyncLeaveRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* PrepareAsyncLeaveRoomRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::Proto::LastMoveInfo>* SpectateRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request) override;
    ::grpc::ClientAsyncReader< ::Proto::LastMoveInfo>* AsyncSpectateRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::Proto::LastMoveInfo>* PrepareAsyncSpectateRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* AsyncLeaveSpectatorRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* PrepareAsyncLeaveSpectatorRoomRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Integer>* AsyncGetViewersCountRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Integer>* PrepareAsyncGetViewersCountRaw(::grpc::ClientContext* context, const ::Proto::String& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::String>* AsyncGetUsernameRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::String>* PrepareAsyncGetUsernameRaw(::grpc::ClientContext* context, const ::Proto::RoomWithUsername& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* AsyncWaitForReadyRaw(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* PrepareAsyncWaitForReadyRaw(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* AsyncReadyRaw(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* PrepareAsyncReadyRaw(::grpc::ClientContext* context, const ::Proto::ReadyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* AsyncMovePieceRaw(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* PrepareAsyncMovePieceRaw(::grpc::ClientContext* context, const ::Proto::MoveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::LastMoveInfo>* AsyncReadPieceMoveRaw(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::LastMoveInfo>* PrepareAsyncReadPieceMoveRaw(::grpc::ClientContext* context, const ::Proto::RoomSettings& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* AsyncSetKingHittableRaw(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Proto::Empty>* PrepareAsyncSetKingHittableRaw(::grpc::ClientContext* context, const ::Proto::RoomWithIsKingHittable& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetRooms_;
    const ::grpc::internal::RpcMethod rpcmethod_IsRoomExists_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateRoom_;
    const ::grpc::internal::RpcMethod rpcmethod_JoinRoom_;
    const ::grpc::internal::RpcMethod rpcmethod_LeaveRoom_;
    const ::grpc::internal::RpcMethod rpcmethod_SpectateRoom_;
    const ::grpc::internal::RpcMethod rpcmethod_LeaveSpectatorRoom_;
    const ::grpc::internal::RpcMethod rpcmethod_GetViewersCount_;
    const ::grpc::internal::RpcMethod rpcmethod_GetUsername_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitForReady_;
    const ::grpc::internal::RpcMethod rpcmethod_Ready_;
    const ::grpc::internal::RpcMethod rpcmethod_MovePiece_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadPieceMove_;
    const ::grpc::internal::RpcMethod rpcmethod_SetKingHittable_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetRooms(::grpc::ServerContext* context, const ::Proto::Empty* request, ::Proto::RoomsInfo* response);
    virtual ::grpc::Status IsRoomExists(::grpc::ServerContext* context, const ::Proto::String* request, ::Proto::Bool* response);
    virtual ::grpc::Status CreateRoom(::grpc::ServerContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response);
    virtual ::grpc::Status JoinRoom(::grpc::ServerContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response);
    virtual ::grpc::Status LeaveRoom(::grpc::ServerContext* context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response);
    virtual ::grpc::Status SpectateRoom(::grpc::ServerContext* context, const ::Proto::String* request, ::grpc::ServerWriter< ::Proto::LastMoveInfo>* writer);
    virtual ::grpc::Status LeaveSpectatorRoom(::grpc::ServerContext* context, const ::Proto::String* request, ::Proto::Empty* response);
    virtual ::grpc::Status GetViewersCount(::grpc::ServerContext* context, const ::Proto::String* request, ::Proto::Integer* response);
    virtual ::grpc::Status GetUsername(::grpc::ServerContext* context, const ::Proto::RoomWithUsername* request, ::Proto::String* response);
    virtual ::grpc::Status WaitForReady(::grpc::ServerContext* context, const ::Proto::RoomSettings* request, ::Proto::Empty* response);
    virtual ::grpc::Status Ready(::grpc::ServerContext* context, const ::Proto::ReadyRequest* request, ::Proto::Empty* response);
    virtual ::grpc::Status MovePiece(::grpc::ServerContext* context, const ::Proto::MoveRequest* request, ::Proto::Empty* response);
    virtual ::grpc::Status ReadPieceMove(::grpc::ServerContext* context, const ::Proto::RoomSettings* request, ::Proto::LastMoveInfo* response);
    virtual ::grpc::Status SetKingHittable(::grpc::ServerContext* context, const ::Proto::RoomWithIsKingHittable* request, ::Proto::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRooms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRooms() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetRooms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRooms(::grpc::ServerContext* /*context*/, const ::Proto::Empty* /*request*/, ::Proto::RoomsInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRooms(::grpc::ServerContext* context, ::Proto::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Proto::RoomsInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsRoomExists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsRoomExists() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_IsRoomExists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsRoomExists(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsRoomExists(::grpc::ServerContext* context, ::Proto::String* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Bool>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateRoom() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_CreateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateRoom(::grpc::ServerContext* context, ::Proto::RoomWithUsername* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JoinRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JoinRoom() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_JoinRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinRoom(::grpc::ServerContext* context, ::Proto::RoomWithUsername* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeaveRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeaveRoom() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_LeaveRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaveRoom(::grpc::ServerContext* context, ::Proto::RoomWithUsername* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpectateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpectateRoom() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SpectateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpectateRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::grpc::ServerWriter< ::Proto::LastMoveInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpectateRoom(::grpc::ServerContext* context, ::Proto::String* request, ::grpc::ServerAsyncWriter< ::Proto::LastMoveInfo>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeaveSpectatorRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeaveSpectatorRoom() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_LeaveSpectatorRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveSpectatorRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaveSpectatorRoom(::grpc::ServerContext* context, ::Proto::String* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetViewersCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetViewersCount() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetViewersCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViewersCount(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Integer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetViewersCount(::grpc::ServerContext* context, ::Proto::String* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Integer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetUsername : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetUsername() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetUsername() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsername(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::String* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUsername(::grpc::ServerContext* context, ::Proto::RoomWithUsername* request, ::grpc::ServerAsyncResponseWriter< ::Proto::String>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitForReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WaitForReady() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_WaitForReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForReady(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitForReady(::grpc::ServerContext* context, ::Proto::RoomSettings* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Ready : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ready() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_Ready() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ready(::grpc::ServerContext* /*context*/, const ::Proto::ReadyRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReady(::grpc::ServerContext* context, ::Proto::ReadyRequest* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MovePiece : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MovePiece() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_MovePiece() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MovePiece(::grpc::ServerContext* /*context*/, const ::Proto::MoveRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMovePiece(::grpc::ServerContext* context, ::Proto::MoveRequest* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadPieceMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadPieceMove() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_ReadPieceMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadPieceMove(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::LastMoveInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadPieceMove(::grpc::ServerContext* context, ::Proto::RoomSettings* request, ::grpc::ServerAsyncResponseWriter< ::Proto::LastMoveInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetKingHittable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetKingHittable() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_SetKingHittable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetKingHittable(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithIsKingHittable* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetKingHittable(::grpc::ServerContext* context, ::Proto::RoomWithIsKingHittable* request, ::grpc::ServerAsyncResponseWriter< ::Proto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetRooms<WithAsyncMethod_IsRoomExists<WithAsyncMethod_CreateRoom<WithAsyncMethod_JoinRoom<WithAsyncMethod_LeaveRoom<WithAsyncMethod_SpectateRoom<WithAsyncMethod_LeaveSpectatorRoom<WithAsyncMethod_GetViewersCount<WithAsyncMethod_GetUsername<WithAsyncMethod_WaitForReady<WithAsyncMethod_Ready<WithAsyncMethod_MovePiece<WithAsyncMethod_ReadPieceMove<WithAsyncMethod_SetKingHittable<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRooms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRooms() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::Empty, ::Proto::RoomsInfo>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::Empty* request, ::Proto::RoomsInfo* response) { return this->GetRooms(context, request, response); }));}
    void SetMessageAllocatorFor_GetRooms(
        ::grpc::experimental::MessageAllocator< ::Proto::Empty, ::Proto::RoomsInfo>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::Empty, ::Proto::RoomsInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRooms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRooms(::grpc::ServerContext* /*context*/, const ::Proto::Empty* /*request*/, ::Proto::RoomsInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRooms(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::Empty* /*request*/, ::Proto::RoomsInfo* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRooms(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::Empty* /*request*/, ::Proto::RoomsInfo* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_IsRoomExists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_IsRoomExists() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::String, ::Proto::Bool>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::String* request, ::Proto::Bool* response) { return this->IsRoomExists(context, request, response); }));}
    void SetMessageAllocatorFor_IsRoomExists(
        ::grpc::experimental::MessageAllocator< ::Proto::String, ::Proto::Bool>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::String, ::Proto::Bool>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_IsRoomExists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsRoomExists(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsRoomExists(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Bool* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsRoomExists(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Bool* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithUsername, ::Proto::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response) { return this->CreateRoom(context, request, response); }));}
    void SetMessageAllocatorFor_CreateRoom(
        ::grpc::experimental::MessageAllocator< ::Proto::RoomWithUsername, ::Proto::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithUsername, ::Proto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_JoinRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_JoinRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithUsername, ::Proto::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response) { return this->JoinRoom(context, request, response); }));}
    void SetMessageAllocatorFor_JoinRoom(
        ::grpc::experimental::MessageAllocator< ::Proto::RoomWithUsername, ::Proto::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithUsername, ::Proto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_JoinRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JoinRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JoinRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LeaveRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LeaveRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithUsername, ::Proto::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::RoomWithUsername* request, ::Proto::Empty* response) { return this->LeaveRoom(context, request, response); }));}
    void SetMessageAllocatorFor_LeaveRoom(
        ::grpc::experimental::MessageAllocator< ::Proto::RoomWithUsername, ::Proto::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithUsername, ::Proto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LeaveRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaveRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaveRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SpectateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SpectateRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::Proto::String, ::Proto::LastMoveInfo>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::String* request) { return this->SpectateRoom(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SpectateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpectateRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::grpc::ServerWriter< ::Proto::LastMoveInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::Proto::LastMoveInfo>* SpectateRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::String* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::Proto::LastMoveInfo>* SpectateRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::String* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LeaveSpectatorRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LeaveSpectatorRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::String, ::Proto::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::String* request, ::Proto::Empty* response) { return this->LeaveSpectatorRoom(context, request, response); }));}
    void SetMessageAllocatorFor_LeaveSpectatorRoom(
        ::grpc::experimental::MessageAllocator< ::Proto::String, ::Proto::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::String, ::Proto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LeaveSpectatorRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveSpectatorRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaveSpectatorRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaveSpectatorRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetViewersCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetViewersCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::String, ::Proto::Integer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::String* request, ::Proto::Integer* response) { return this->GetViewersCount(context, request, response); }));}
    void SetMessageAllocatorFor_GetViewersCount(
        ::grpc::experimental::MessageAllocator< ::Proto::String, ::Proto::Integer>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::String, ::Proto::Integer>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetViewersCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViewersCount(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Integer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetViewersCount(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Integer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetViewersCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Integer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetUsername : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetUsername() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithUsername, ::Proto::String>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::RoomWithUsername* request, ::Proto::String* response) { return this->GetUsername(context, request, response); }));}
    void SetMessageAllocatorFor_GetUsername(
        ::grpc::experimental::MessageAllocator< ::Proto::RoomWithUsername, ::Proto::String>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithUsername, ::Proto::String>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetUsername() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsername(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::String* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetUsername(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::String* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetUsername(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::String* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WaitForReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WaitForReady() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomSettings, ::Proto::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::RoomSettings* request, ::Proto::Empty* response) { return this->WaitForReady(context, request, response); }));}
    void SetMessageAllocatorFor_WaitForReady(
        ::grpc::experimental::MessageAllocator< ::Proto::RoomSettings, ::Proto::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomSettings, ::Proto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WaitForReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForReady(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WaitForReady(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WaitForReady(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Ready : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Ready() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::ReadyRequest, ::Proto::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::ReadyRequest* request, ::Proto::Empty* response) { return this->Ready(context, request, response); }));}
    void SetMessageAllocatorFor_Ready(
        ::grpc::experimental::MessageAllocator< ::Proto::ReadyRequest, ::Proto::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::ReadyRequest, ::Proto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Ready() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ready(::grpc::ServerContext* /*context*/, const ::Proto::ReadyRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ready(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::ReadyRequest* /*request*/, ::Proto::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ready(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::ReadyRequest* /*request*/, ::Proto::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MovePiece : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MovePiece() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::MoveRequest, ::Proto::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::MoveRequest* request, ::Proto::Empty* response) { return this->MovePiece(context, request, response); }));}
    void SetMessageAllocatorFor_MovePiece(
        ::grpc::experimental::MessageAllocator< ::Proto::MoveRequest, ::Proto::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::MoveRequest, ::Proto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MovePiece() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MovePiece(::grpc::ServerContext* /*context*/, const ::Proto::MoveRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MovePiece(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::MoveRequest* /*request*/, ::Proto::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MovePiece(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::MoveRequest* /*request*/, ::Proto::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadPieceMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadPieceMove() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomSettings, ::Proto::LastMoveInfo>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::RoomSettings* request, ::Proto::LastMoveInfo* response) { return this->ReadPieceMove(context, request, response); }));}
    void SetMessageAllocatorFor_ReadPieceMove(
        ::grpc::experimental::MessageAllocator< ::Proto::RoomSettings, ::Proto::LastMoveInfo>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomSettings, ::Proto::LastMoveInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadPieceMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadPieceMove(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::LastMoveInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadPieceMove(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::LastMoveInfo* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadPieceMove(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::LastMoveInfo* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetKingHittable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetKingHittable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithIsKingHittable, ::Proto::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::Proto::RoomWithIsKingHittable* request, ::Proto::Empty* response) { return this->SetKingHittable(context, request, response); }));}
    void SetMessageAllocatorFor_SetKingHittable(
        ::grpc::experimental::MessageAllocator< ::Proto::RoomWithIsKingHittable, ::Proto::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::Proto::RoomWithIsKingHittable, ::Proto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetKingHittable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetKingHittable(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithIsKingHittable* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetKingHittable(
      ::grpc::CallbackServerContext* /*context*/, const ::Proto::RoomWithIsKingHittable* /*request*/, ::Proto::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetKingHittable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::Proto::RoomWithIsKingHittable* /*request*/, ::Proto::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetRooms<ExperimentalWithCallbackMethod_IsRoomExists<ExperimentalWithCallbackMethod_CreateRoom<ExperimentalWithCallbackMethod_JoinRoom<ExperimentalWithCallbackMethod_LeaveRoom<ExperimentalWithCallbackMethod_SpectateRoom<ExperimentalWithCallbackMethod_LeaveSpectatorRoom<ExperimentalWithCallbackMethod_GetViewersCount<ExperimentalWithCallbackMethod_GetUsername<ExperimentalWithCallbackMethod_WaitForReady<ExperimentalWithCallbackMethod_Ready<ExperimentalWithCallbackMethod_MovePiece<ExperimentalWithCallbackMethod_ReadPieceMove<ExperimentalWithCallbackMethod_SetKingHittable<Service > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetRooms<ExperimentalWithCallbackMethod_IsRoomExists<ExperimentalWithCallbackMethod_CreateRoom<ExperimentalWithCallbackMethod_JoinRoom<ExperimentalWithCallbackMethod_LeaveRoom<ExperimentalWithCallbackMethod_SpectateRoom<ExperimentalWithCallbackMethod_LeaveSpectatorRoom<ExperimentalWithCallbackMethod_GetViewersCount<ExperimentalWithCallbackMethod_GetUsername<ExperimentalWithCallbackMethod_WaitForReady<ExperimentalWithCallbackMethod_Ready<ExperimentalWithCallbackMethod_MovePiece<ExperimentalWithCallbackMethod_ReadPieceMove<ExperimentalWithCallbackMethod_SetKingHittable<Service > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetRooms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRooms() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetRooms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRooms(::grpc::ServerContext* /*context*/, const ::Proto::Empty* /*request*/, ::Proto::RoomsInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsRoomExists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsRoomExists() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_IsRoomExists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsRoomExists(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateRoom() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_CreateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JoinRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JoinRoom() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_JoinRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeaveRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeaveRoom() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_LeaveRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpectateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpectateRoom() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SpectateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpectateRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::grpc::ServerWriter< ::Proto::LastMoveInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeaveSpectatorRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeaveSpectatorRoom() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_LeaveSpectatorRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveSpectatorRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetViewersCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetViewersCount() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetViewersCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViewersCount(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Integer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetUsername : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetUsername() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetUsername() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsername(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::String* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitForReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WaitForReady() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_WaitForReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForReady(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Ready : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ready() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_Ready() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ready(::grpc::ServerContext* /*context*/, const ::Proto::ReadyRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MovePiece : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MovePiece() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_MovePiece() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MovePiece(::grpc::ServerContext* /*context*/, const ::Proto::MoveRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadPieceMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadPieceMove() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_ReadPieceMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadPieceMove(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::LastMoveInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetKingHittable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetKingHittable() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_SetKingHittable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetKingHittable(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithIsKingHittable* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRooms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRooms() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetRooms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRooms(::grpc::ServerContext* /*context*/, const ::Proto::Empty* /*request*/, ::Proto::RoomsInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRooms(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsRoomExists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsRoomExists() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_IsRoomExists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsRoomExists(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsRoomExists(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateRoom() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_CreateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateRoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JoinRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JoinRoom() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_JoinRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinRoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeaveRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeaveRoom() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_LeaveRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaveRoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpectateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpectateRoom() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SpectateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpectateRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::grpc::ServerWriter< ::Proto::LastMoveInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpectateRoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeaveSpectatorRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeaveSpectatorRoom() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_LeaveSpectatorRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveSpectatorRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaveSpectatorRoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetViewersCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetViewersCount() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetViewersCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViewersCount(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Integer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetViewersCount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetUsername : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetUsername() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetUsername() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsername(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::String* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUsername(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitForReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WaitForReady() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_WaitForReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForReady(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitForReady(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ready : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ready() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_Ready() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ready(::grpc::ServerContext* /*context*/, const ::Proto::ReadyRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReady(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MovePiece : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MovePiece() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_MovePiece() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MovePiece(::grpc::ServerContext* /*context*/, const ::Proto::MoveRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMovePiece(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadPieceMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadPieceMove() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_ReadPieceMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadPieceMove(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::LastMoveInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadPieceMove(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetKingHittable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetKingHittable() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_SetKingHittable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetKingHittable(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithIsKingHittable* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetKingHittable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRooms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRooms() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRooms(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRooms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRooms(::grpc::ServerContext* /*context*/, const ::Proto::Empty* /*request*/, ::Proto::RoomsInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRooms(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRooms(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_IsRoomExists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_IsRoomExists() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsRoomExists(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_IsRoomExists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsRoomExists(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsRoomExists(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsRoomExists(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateRoom(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_JoinRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_JoinRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JoinRoom(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_JoinRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JoinRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JoinRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LeaveRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LeaveRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeaveRoom(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LeaveRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaveRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaveRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SpectateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SpectateRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SpectateRoom(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SpectateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpectateRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::grpc::ServerWriter< ::Proto::LastMoveInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SpectateRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SpectateRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LeaveSpectatorRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LeaveSpectatorRoom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeaveSpectatorRoom(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LeaveSpectatorRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveSpectatorRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaveSpectatorRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaveSpectatorRoom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetViewersCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetViewersCount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetViewersCount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetViewersCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetViewersCount(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Integer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetViewersCount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetViewersCount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetUsername : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetUsername() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetUsername(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetUsername() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsername(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::String* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetUsername(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetUsername(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WaitForReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WaitForReady() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WaitForReady(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WaitForReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForReady(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WaitForReady(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WaitForReady(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Ready : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Ready() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ready(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Ready() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ready(::grpc::ServerContext* /*context*/, const ::Proto::ReadyRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ready(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ready(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MovePiece : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MovePiece() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MovePiece(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MovePiece() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MovePiece(::grpc::ServerContext* /*context*/, const ::Proto::MoveRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MovePiece(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MovePiece(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadPieceMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadPieceMove() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadPieceMove(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadPieceMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadPieceMove(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::LastMoveInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadPieceMove(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadPieceMove(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetKingHittable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetKingHittable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetKingHittable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetKingHittable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetKingHittable(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithIsKingHittable* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetKingHittable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetKingHittable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRooms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRooms() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::Empty, ::Proto::RoomsInfo>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::Empty, ::Proto::RoomsInfo>* streamer) {
                       return this->StreamedGetRooms(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRooms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRooms(::grpc::ServerContext* /*context*/, const ::Proto::Empty* /*request*/, ::Proto::RoomsInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRooms(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::Empty,::Proto::RoomsInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsRoomExists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsRoomExists() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::String, ::Proto::Bool>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::String, ::Proto::Bool>* streamer) {
                       return this->StreamedIsRoomExists(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsRoomExists() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsRoomExists(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Bool* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsRoomExists(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::String,::Proto::Bool>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateRoom() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::RoomWithUsername, ::Proto::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::RoomWithUsername, ::Proto::Empty>* streamer) {
                       return this->StreamedCreateRoom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateRoom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::RoomWithUsername,::Proto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JoinRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JoinRoom() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::RoomWithUsername, ::Proto::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::RoomWithUsername, ::Proto::Empty>* streamer) {
                       return this->StreamedJoinRoom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JoinRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JoinRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJoinRoom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::RoomWithUsername,::Proto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeaveRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeaveRoom() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::RoomWithUsername, ::Proto::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::RoomWithUsername, ::Proto::Empty>* streamer) {
                       return this->StreamedLeaveRoom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeaveRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeaveRoom(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeaveRoom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::RoomWithUsername,::Proto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeaveSpectatorRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeaveSpectatorRoom() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::String, ::Proto::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::String, ::Proto::Empty>* streamer) {
                       return this->StreamedLeaveSpectatorRoom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeaveSpectatorRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeaveSpectatorRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeaveSpectatorRoom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::String,::Proto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetViewersCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetViewersCount() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::String, ::Proto::Integer>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::String, ::Proto::Integer>* streamer) {
                       return this->StreamedGetViewersCount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetViewersCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetViewersCount(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::Proto::Integer* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetViewersCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::String,::Proto::Integer>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetUsername : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetUsername() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::RoomWithUsername, ::Proto::String>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::RoomWithUsername, ::Proto::String>* streamer) {
                       return this->StreamedGetUsername(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetUsername() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetUsername(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithUsername* /*request*/, ::Proto::String* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetUsername(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::RoomWithUsername,::Proto::String>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitForReady : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WaitForReady() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::RoomSettings, ::Proto::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::RoomSettings, ::Proto::Empty>* streamer) {
                       return this->StreamedWaitForReady(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WaitForReady() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitForReady(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitForReady(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::RoomSettings,::Proto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ready : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ready() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::ReadyRequest, ::Proto::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::ReadyRequest, ::Proto::Empty>* streamer) {
                       return this->StreamedReady(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ready() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ready(::grpc::ServerContext* /*context*/, const ::Proto::ReadyRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReady(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::ReadyRequest,::Proto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MovePiece : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MovePiece() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::MoveRequest, ::Proto::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::MoveRequest, ::Proto::Empty>* streamer) {
                       return this->StreamedMovePiece(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MovePiece() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MovePiece(::grpc::ServerContext* /*context*/, const ::Proto::MoveRequest* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMovePiece(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::MoveRequest,::Proto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadPieceMove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadPieceMove() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::RoomSettings, ::Proto::LastMoveInfo>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::RoomSettings, ::Proto::LastMoveInfo>* streamer) {
                       return this->StreamedReadPieceMove(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadPieceMove() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadPieceMove(::grpc::ServerContext* /*context*/, const ::Proto::RoomSettings* /*request*/, ::Proto::LastMoveInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadPieceMove(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::RoomSettings,::Proto::LastMoveInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetKingHittable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetKingHittable() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Proto::RoomWithIsKingHittable, ::Proto::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::Proto::RoomWithIsKingHittable, ::Proto::Empty>* streamer) {
                       return this->StreamedSetKingHittable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetKingHittable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetKingHittable(::grpc::ServerContext* /*context*/, const ::Proto::RoomWithIsKingHittable* /*request*/, ::Proto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetKingHittable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Proto::RoomWithIsKingHittable,::Proto::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetRooms<WithStreamedUnaryMethod_IsRoomExists<WithStreamedUnaryMethod_CreateRoom<WithStreamedUnaryMethod_JoinRoom<WithStreamedUnaryMethod_LeaveRoom<WithStreamedUnaryMethod_LeaveSpectatorRoom<WithStreamedUnaryMethod_GetViewersCount<WithStreamedUnaryMethod_GetUsername<WithStreamedUnaryMethod_WaitForReady<WithStreamedUnaryMethod_Ready<WithStreamedUnaryMethod_MovePiece<WithStreamedUnaryMethod_ReadPieceMove<WithStreamedUnaryMethod_SetKingHittable<Service > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SpectateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SpectateRoom() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::Proto::String, ::Proto::LastMoveInfo>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::Proto::String, ::Proto::LastMoveInfo>* streamer) {
                       return this->StreamedSpectateRoom(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SpectateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpectateRoom(::grpc::ServerContext* /*context*/, const ::Proto::String* /*request*/, ::grpc::ServerWriter< ::Proto::LastMoveInfo>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSpectateRoom(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::Proto::String,::Proto::LastMoveInfo>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SpectateRoom<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetRooms<WithStreamedUnaryMethod_IsRoomExists<WithStreamedUnaryMethod_CreateRoom<WithStreamedUnaryMethod_JoinRoom<WithStreamedUnaryMethod_LeaveRoom<WithSplitStreamingMethod_SpectateRoom<WithStreamedUnaryMethod_LeaveSpectatorRoom<WithStreamedUnaryMethod_GetViewersCount<WithStreamedUnaryMethod_GetUsername<WithStreamedUnaryMethod_WaitForReady<WithStreamedUnaryMethod_Ready<WithStreamedUnaryMethod_MovePiece<WithStreamedUnaryMethod_ReadPieceMove<WithStreamedUnaryMethod_SetKingHittable<Service > > > > > > > > > > > > > > StreamedService;
};

}  // namespace Proto


#endif  // GRPC_ChessServer_2eproto__INCLUDED
